[["Regression","2024年04月04日","/2024/04/06/regression.html/","\rRegression\r下面来根据一个示例来讲一下线性回归模型 背景\rimg\r根据宝可梦的初始cp值，type, weight, height来预测进化后的cp值 Step 1 ：Model\r第一步我们需要在function集中找出最好的拟合函数 我们可以使用一个Linear Model: y = b + w ^ Xcp 来简单拟合 Step 2 : Goodness of function\r第二步我们需要找到一个数据集，这个数据集包括我们需要输入的数据以及其对应的正确输出数据 img\r我们还需要找到一个评估对应参数b和参数w好坏的function：Loss function 普通的Loss function 为 img\r其中hat y 是训练集中正确的y值，当然这个Loss function结果越小越好 那么我们怎么找出这个对应Loss function结果最小的参数b,w呢？ 我们可以使用Gradient Descent来完成 Step 3 : Gradient Descent\r简单起见我们可以暂时先考虑一个参数w img\r可以通过以下步骤： 选取一个起始点w = w0 计算这个点L(w)对w的导数，导数小于0则说明函数成下降趋势，大于0则说明函数成上升趋势，因为我们需要找出最小的L(w)，所以可以根据导数的正负来更新w0，例如下图选取点为w1（注：参数η为关系变化快慢的参数） img\r重复取新点执行步骤2，最终会得到一个局部最小值点（为什么是局部呢，因为根据导数只会选取下降的点，但是Linear Model不用考虑这个问题，因为它没有局部最优解） 学会一维后，其实二维也大同小异： img\r最终移动方向其实为法线方向 Result\r通过上诉步骤我们可以得到一个上诉模型的最优解 img\r我们可以计算每个训练数据的差值，并算出一个总差值train e 再算出测试数据集中数据的差值，并算出一个总差值test e 那么我们怎么获取到更准确的function呢？ 我们需要重新找出更适合的model，再从Step1一步一步执行,比如 img\r当然我们也可以到Xcp的三次方，四次方等等，最终可以得到以下数据 img\r右图分别为对应训练集和测试集上的误差 可以发现四次方，五次方已经出现了over fitting的情况 那么我们怎么解决这种情况呢？ 可以回到Step 2进行Regularization img\r可以在Loss Function后面增加一部分来使曲线尽可能的平滑，其中参数可调 "],["ChatGPT原理剖析","2024年04月04日","/2024/04/05/chatgpt%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html/","\rChatGPT原理剖析\r文字接龙\r根据用户的输入来获取一个概率图表，从这个图表中选择一个字（这个字可能并不是概率最高的那一个） img\r用一个例子来说明，比如用户输入什么是机器学习，那么程序会结合这个字符串来计算一个概率表，以这个概率表来输出下一个字。 那么如果用户下一次输入直接输入你回答的不够详细，请具体说明，那么程序会将之前的输入和新输入的字符串结合来算出新的概率表，再通过相同的流程来输出下一个字，类似于一种文字接龙。 训练原理\r预训练（自督导式学习）-\u0026gt; 督导式学习 -\u0026gt; 增强式学习（Reinforcement Learning, RL） 预训练（自督导式学习）\r给定特定的数据集，学习样本数据的表述特征来应用于未来的问题。 img\r例如这样一个例子，数据集中有世界第一高峰是喜马拉雅山这句话，那么当之后有人问这个问题时，GPT就会回答这个问题喜马拉雅山。 经过预训练后会有一种现象： img\r我们可以看到经过一百多种语言的预训练之后，即使只完成了英文问答的训练，没有完成中文问答的训练，他最后在中文问答测试上的准确率和没有经过预训练，而通过中文问答训练的最终准确率相差不大。 督导式学习\r人类再给GPT数据集之外的一些问题答案，给GPT加以训练 img\rGPT经过督导式学习后就变成了ChatGPT 增强式学习（Reinforcement Learning, RL）\rimg\rChatGPT在督导式学习的基础上还会进行增强式学习，这种学习不需要人类直接给出问题的答案。 比如上面这个例子，用户问请帮我赞美AI这个问题，由ChatGPT进行回答，人类只需要对这个问题的答案进行打分来评价回答的好与坏，让ChatGPT自己调整即可。 ChatGPT带来的研究课题\r1. 如何精确提出需求\r举一个例子： img\r如果只是单纯的跟ChatGPT对话，“我今天工作很累”，那么它并不会像人一样和你聊天。 我们必须对他进行催眠（Prompting)，精确到具体场景： img\r这样才可以完成自己想要的对话。 2. 如何更正错误\r因为ChatGPT的认识只截止到2021年，对2021年之后的事情并不完全知道，所以在回答时可能会出现错误。 比如说： 问ChatGPT最近的世界杯足球赛冠军是谁，那么他只能回答到2018年的冠军，这个回答显然是错误的，但是当我们尝试告诉它最近的冠军是阿根廷时，可能这个问题它知道了答案，但是由于修改了里面的参数，可能修改对了一个答案，但是改错了很多正确答案。 3. 侦测AI生成的物件\r例如怎样用模型侦测一段文字是否是AI生成的。 普通的训练就是由人类对一些文字添加标签，再使用这些数据集对模型进行训练。 4. AI泄露机密\r早期GPT的数据集可能是直接从网上爬取的各种文件，那么会不会爬取到机要领域呢。 比如说GPT-2： img\r"],["Activity的生命周期和启动模式","2022年04月04日","/2022/04/15/activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html/","\rActivity的生命周期和启动\rimg\r:初始化工作，加载页面布局，初始化所需数据等等。 :表示 正在重新启动，从不可见状态变为可见状态时会调用。例如：用户从这个应用切换到其他应用再回到这个应用时 表示 正在启动，这时 已经可见，但还没有出现在前台，也就是用户不可见。 : 已经出现在前台，可以和用户进行交互 :正常情况下紧接着 会开始调用，在这个方法中可以进行数据的存储，停止动画，但是不能太耗时，会影响下一个 的显示，这个 先执行完 才会执行下一个 的 : 即将停止，在这个方法可以做一些轻量的回收工作 : 即将销毁， 生命周期的最后一个方法，可以做一些资源的释放和回收工作 "],["Android UI绘制原理","2022年04月04日","/2022/04/15/android-ui%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86.html/","\rAndroid UI绘制原理\r的视图结构\rActivity的视图结构\r这是 的一个视图结构图，从这张图可以看出来 中包含着一层 ，而这层 其实是一个 ， 层的事件都需要通过这一层才能传给我们自己设置的布局。 作为顶层 ，内部包含一个 ，然后就像上图一样，上面是标题栏，下面是内容栏，这也是为什么 的 方法中是 的原因了 View绘制的入口\r当 被创建完毕后，会将 添加到 中，同时会创建 对象，并将 对象和 联系起来： 而 的绘制流程是从 的 开始，在这个方法中会依次调用 , , 方法： img\r子元素会重复父容器的这些过程，这样反复就完成了整个 的遍历， 过程中不同的是在 方法中调用 方法来实现，但本质基本相同。 MeasureSpec\r在测量过程中，系统会将 的 根据父容器指定的规则转换成相应的 ，然后再根据 来测量宽高，这是一个32位的 值，高二位表示 ,低三十位表示 ,但根据这个获得的宽高不一定是最终的宽高，最终的宽高由 决定。 三类 : UNSPECIFIED 父容器不对 做任何限制，要多大给多大 EXACTLY 父容器已经检测出 的精确大小，这个时候 的最终大小就是 所指定的值，它对应于 和具体的数值这两种模式 AT_MOST 父容器指定了一个可用大小也即 , 的大小不能大于这个值，它对应于 下面是 的创建过程 其中 和 是屏幕的大小，它会根据 的宽高参数来划分 下面是 的 方法 从上面代码可以知道子元素的 与自己的 和父元素的 有关 而 就是根据父元素的 来进行不同的操作，可以归结为下面一张表 img\rMeasure过程\r由于 的 方法为 ,没办法重写，但是在这个方法中调用了 方法，可以重写这个方法 这是这个方法的默认实现，发现调用了 这个方法，查看这个方法的源码 发现它会根据父元素的 进行选择，如果是 ,就为传入的 否则就为 测量后的大小 ,另外，从这一段代码还有上表可以知道在自定义控件中如果直接继承 就需要自己配置 时的 ，因为如果传入的是 ，那么对应的 就是 ，在这个模式下， 的大小始终为父元素所剩余的空间大小，也就和 的效果一样。 对于 ，除了完成自己的 过程，还要遍历子元素，提供了一个 方法 在这个方法中会遍历每一个子 ,在这个方法中又会调用 方法， 获取到子元素的 后在执行子元素的 方法 Layout过程\r这个过程用来确定位置，当 的位置被确定后他会遍历所有的子元素并调用其 方法，在这个方法中又会调用 方法 观看源码可知，在 方法中首先会调用 方法来初始化四个顶点的位置，接着会调用 方法，这个方法用于父容器确定子元素的位置 在 中就会遍历每个子元素，执行其 方法，这样重复遍历就完成了整个 的 过程 Draw过程\r从这段代码可以看出来， 过程遵循如下几步： 绘制背景 在背景不为空的条件下会调用 方法进行背景的绘制 绘制自己 (空) 绘制 （ 中被实现） 绘制装饰 为什么不能在子线程中更新UI\r设计原因：因为如果可以在子线程中更新 就会有频繁的加锁和锁释放，这样就会造成很大的内存开销，会造成视觉上的不流畅，所以不允许在子线程中执行这样的操作，会抛出异常。 更新 的时候最终都会调用到高层 的 的方法 会发现在这个方法中调用了 这个方法，查看这个方法的源码 会发现就是在这个方法中检查现在的县城并抛出了异常，其中的 就是 创建并初始化的线程 可以发现在 时仍然不能够确定 "],["Android 事件分发","2022年04月04日","/2022/04/15/android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html/","\rAndroid 事件分发\r几个重要的对象\rMotionEvent\r在手指触摸屏幕时会有下面几种典型事件 ACTION_DOWN:手指刚接触屏幕 ACTION_MOVE:手指在屏幕上滑动 ACTION_UP:手指从屏幕上松开的一瞬间 其中 点击屏幕后立即松开，事件序列为DOWN-\u0026gt;UP 点击屏幕滑动一会再松开，事件序列为DOWN-\u0026gt;MOVE-\u0026gt;MOVE\u0026hellip;-\u0026gt;UP 这个MOTION_EVENT对象可以通过以下方法得到点击事件发生的x,y坐标 和 这两个方法是返回相当于当前 的左上角的坐标 和 返回的是相对于手机屏幕左上角的坐标 TouchSlop\r是系统能识别出的被认为是滑动的最小距离，如果滑动的距离小于这个值就相当于没有滑动，这是一个常量，和设备有关，可以通过 来获取这个常量 VelocityTracker\r这个对象用于追踪手指在滑动过程中的速度，在 的 方法中追踪当前点击事件的速度： 在获取速度之前必须调用 方法计算速度，可以用：速度 = （终点位置 - 起点位置） / 时间段 来表示，并且 中的参数单位为毫秒。 在不使用时就调用 和 方法 GestureDetector\r这个对象用于检测用户的单击，滑动，长按，双击等行为 根据需要可以实现 和 接口，创建 的对象 接着接管目标 的 方法，在待监听的 中添加 顶级view的事件分发\r点击事件的事件分发就是对 事件的分发过程，当一个 产生了之后，系统把这个事件传递给一个具体的 的过程，主要涉及到三个重要的方法： , , 这个方法用来进行事件的分发，如果事件能够传递到一个 那么这个 的这个方法一定会被调用，返回的结果受当前 的 和下级 的 影响，表示是否消耗当前的事件 在上边这个方法内部调用，用来判断是否拦截某个事件，如果 拦截了某个事件，那么在同一个时间序列中这个方法不会被再次调用，返回结果表示是否拦截当前事件。 在 方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，那么在同一个时间序列中当前的 无法再次接受到这个事件 事件传递时会先传递到 并调用其 方法 可以发现在 的这个方法中调用了 方法，而 对象的实现类是 ，所以事件其实分发给了 ,查看这个文件中的 方法： 发现又将事件传递给了顶层 - ,而 是一个 ,也就是一个 ，也就是将事件传递到了 的 中，如果这个 拦截事件则 返回 ，事件由 处理，如果 的 被设置则 会被调用，否则 会被调用，如果都提供的话，那么 会覆盖 , 中如果设置了 则 会被调用，如果顶级 不拦截事件，则事件会传递给他的子 ,这时子 的 会被调用，也就和上面的过程一样了 下面看 的 方法， 其中 是对消耗的 的一个链表形式的保存，如果事件由当前 拦截时那么 就为空，如果传递给子 并交由子元素拦截时那么 就指向子元素 也有一种特殊情况，就是 标记位，这个标记位通过 设置，一般用于子 中，可以拦截除去 以外的其他事件（当事件为 时就会重置这个标志位），当遇到 的事件时， 总会询问自己要不要拦截这个事件， 从这一段代码的 方法重置标志位，通过上面的代码可以发现，当 决定拦截事件后，那么之后的点击事件都会默认交给他来处理，而不会调用 方法 当 不拦截事件时，事件分发给他的子 遍历所有子元素，判断子元素能否接收到点击事件，在 中调用的是子元素的 ，在他的内部有下面一段代码： 而上面传入的 不是 ，所以会调用子元素的 ，如果子元素的这个方法返回 那么 就会呗赋值同时跳出 循环， 其中 的赋值过程在 方法中 如果遍历所有的子元素后事件没有被处理，那么 会自己处理点击事件，从上面的源码就可以得出这个结论 第三个参数为 也就是调用 ,也就是交由 来处理。 view对点击事件的处理过程\r首先看 的 方法 分析上面源码，发现会先判断有没有设置 ，如果其中的 方法返回 ，那么 就不会调用，从这可以发现 的优先级高于 然后是 ， 可以发现，即使 的状态不可用，仍然会消耗点击事件，下面看 中对点击事件的具体处理 从这一段代码可以看出来， 的 和 有一个为true，那么事件就会被消耗，如果 设置了 那么 就会被调用，就会在他内部调用 方法 另外 观察这两个方法会发现设置这两个 会自动将对应的属性设置为 "],["Android 消息机制（native层)","2022年04月04日","/2022/04/15/android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6native%E5%B1%82.html/","\rAndroid 消息机制（native层)\rnative层中一些重要的类： ：和java层中的 同名，里面包含一个 :是 的继承类，是 层的消息队列，只是一个代理类，它的大部分逻辑在 中实现 ：相当于java层的 ，他可以发送消息，取出消息，处理消息 ： 层的消息处理类， 将消息处理的逻辑交给这个类 ：是 的继承类，也是 层的消息处理类，最终还是会把消息处理的逻辑交给 这是java层中声明的一些 方法 nativeInit()\r在 的构造器中创建，在 的构造器中会执行下面代码： 在这里会执行 层的 方法，并将其返回值保存到 中，下面再看一下 层中这个方法的实现： 可以发现在这里创建了一个 对象，增加了其引用计数，并将这个对象的指针强制转换为 类型返回，也就是说java层保存了 层 的指针，下面再看一下 的构造函数： 在这个构造器中实现了线程中 的初始化 下面看一下 层中 的构造函数： 其中 是文件描述符，在 中打开或创建一个文件都会返回一个文件描述符，读写文件需要使用这个文件描述符来指定待读写的文件，所以文件描述符就是指代被打开的文件，所有文件的IO操作都需要这个文件描述符 在这个方法中使用了 机制，下面是对 机制的一些简单了解： 首先调用 方法来建立一个 对象(在 系统中为这个句柄分配空间)， 之后调用 向 对象中进行添加，删除，修改操作 最后调用 收集所有事件的连接 的优点简单来说就是可以显著减少大量并发连接中只有少部分活跃的CPU资源耗费， 那么这一部分总的来说就是以下几个步骤： java层中在 的构造函数中创建 对象 的构造器中又会调用 层的 方法初始化 层的 ，在这个类的构造函数中又会创建 对象，并通过管道和 机制建立一套消息机制 层构建完毕后，会将 层的 对象转换为 类型的数据储存到 层的 的 中 nativePollOnce\r这个方法的调用在 中 方法返回一个 对象，在没有消息时 会进入阻塞 下面看一下这个函数的源码： 这个方法首先从 层中获取到保存的 对象，然后再调用 方法，在这个方法内部又调用了 方法，下面看一下这个方法的实现 该方法也是一个死循环，如果 不等于0，那么就会返回到 层，那么看一下这个 的赋值操作， 这个方法内执行的逻辑大致可分为三步： 执行 方法，等待事件发生或超时 如果文件描述符监听的任何时间发生，那么 就会监听到，并将事件放入到事件集合中，并返回发生的时间数目， 就是从 层中传过来的 ,当值为-1时表示java层的消息队列中没有消息，会一直等待下去，当值为0时就会立即返回,另外 机制只会把发生了的事件放入到事件集合中。 遍历事件集合，检测是哪个文件描述符发生了IO事件 处理native层的 这里面就有一个结构体： 层中的 存放在 中，然后进如循环中，如果到达执行时间，就会调用 的 方法处理消息 nativeWake\r这个方法执行在消息入队时 这个方法最终会调用到 层的 方法 这个方法其实是使用 方法向管道中写入字符inc,如果写入失败就重复写入，直到写入成功为止，这个字符起到一个通知作用，用来通知线程处理消息 java层和native层通过 的JNI进行连接，从而使得 既能处理java层又能处理native层 "],["Android消息机制（Java层）","2022年04月04日","/2022/04/15/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6java%E5%B1%82.html/","\rAndroid 消息机制（Java层)\r与同步机制相反，用于保证多线程情况下各个线程数据的独立性，那么这是如何实现的呢？ 观察 的 方法： 会发现在这个方法中首先会得到当前的线程，然后获取到 对象，如果这个对象不为空，就将数据保存到这个 中，否则就重新创建一个 对象，并将数据保存到这个 中，这个 相当于一个 ，用于保存这个线程中的数据。 然后再看它的 方法： 这个方法跟 方法相同，也是先获取到这个线程的 对象，并判断是否为空，如果为空就返回初始值并保存初始值，否则就返回之前存放的数据。其中 就是获取初始值并保存的方法 可以通过 方法来移除 对应的值 查看 的源码发现每一个 对象都有一个 对象用于保存当前线程的数据，这就保证了多线程之间不会相互影响。 下面再来看一下 ,先来看一下构造方法： 在构造方法中先创建了一个数组，并将第一次的数据存储到这个数组中。 其中 是 中的一个内部类 下面看一下 的 方法： 在这个方法中首先用当前 的 来计算索引值（每创建一个 都会生成一个相应的 值 注意使用了 来保证不同线程状态下的同步 在保存数据时，如果索引的位置有 且 的 为 由于 保存数据的方式是用的弱引用，就会将 进行回收， 下面是获取 ： 因为可能存在哈希冲突，所以可能需要调用 来获取 一些准备工作\r首先看一下 的构造器， 的构造器有很多，下面看最关键的一个 会发现先获取 对象，然后判断是否为空，也就是说在使用这个构造器的时候必须先调用 这个方法，否则就会抛出异常 接着再看一下 的构造方法 发现这是一个私有方法，接着再来看一下他是在哪调用的呢？ 从这里就可以看出来为什么要在一个线程中构造 之前必须调用 方法了，并且这个 对象放在了当前线程的私有内存中，主线程中初始化 对象的逻辑基本相同 并且系统已经帮我们在 类的 方法中调用了这个方法 这里面的 方法是一个死循环，会一直调用 的 方法获取 ，然后交由 处理 初始化工作就这些，下面就是发送消息的环节 发送消息\r下面先看一下 方法 会发现 其实仍然是包装成了一个 对象,下面再看一下 的一系列方法 会发现最终这些 和 方法都会指向 这个方法，下面来看一下这个方法 在这个方法中首先会判断 对象是否为空，不为空的话就会调用 方法 这里会将 对象的 设置为当前的 对象，并且执行消息入队操作 消息入队\r这个方法会根据 对象的 来找到 的位置并插入到队列中，这个队列其实是一个单向链表 同步屏障\r它的主要作用就是及时的更新UI，如果主线程中消息队列中除更新UI外还有其他的消息，那么就会先执行更新UI的操作 发现也是根据 的 来进行消息的入队，但是并没有给这个 对象设置 同步屏障的作用就是屏蔽消息队列中该同步屏障之后的所有同步消息，只处理异步消息，保证异步消息优先执行,可以调用 的 来设置同步或异步消息，也可以通过 构造函数中的参数 来设置，主要应用于UI的绘制 Looper循环和消息出队\r开启一个死循环，在这个循环中获取消息队列中的消息，并进行消息的处理，下面看一下 方法 这个方法也是一个死循环，会进行各种判断，如果消息执行时间还没到，就会设置阻塞时长，另外会判断是否消息屏障，并执行相应的操作 消息处理\r观察 的 其中 是在 系列方法中设置的，而 是在构造器中传入的，其中的 默认实现为空 如果返回 的话表示消息处理结束，不会再继续分发消息，否则会分发给 的 处理然后结束 移除消息\r这利用了两个 循环，前面用来移除从队列头开始移除满足条件了 之后用来移除之后的 "],["Java 高级 - 反射","2022年04月04日","/2022/04/15/java-%E9%AB%98%E7%BA%A7-%E5%8F%8D%E5%B0%84.html/","\rJava 高级 - 反射\r什么是反射\r在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 获取Class对象\r有三种方式： 输出结果为： 其中第三种方法必须为完整的包名加类名。 获取构造器\r公有构造方法 这样就获得一个构造方法的数组。而获取所有的构造方法可以使用： 另外可以指定所获取的构造器的参数： 也可以直接调用获取到的构造方法： 在使用私有构造器时需要使用 来进行强制访问。 获取字段\r与获取构造器类似。 公有字段的引用： 这样就将就将 传给了 对象的 中 所有字段（包括私有字段的引用）： 注意 这一行代码强制调用私有字段，调用公有字段时不需要。 获取方法\r调用获取到的方法： 公有方法： 自己声明的方法（包括私有方法）： 可以通过反射越过泛型： 这样就可以添加 型数据。 "],["Java 高级 - 注解","2022年04月04日","/2022/04/15/java-%E9%AB%98%E7%BA%A7-%E6%B3%A8%E8%A7%A3.html/","\rJava 高级 - 注解\r内置注解\r@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 @SafeVarargs -忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - 标识一个匿名函数或函数式接口。 作用于其他注解的注解（元注解）： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) @Repeatable -标识某注解可以在同一个声明上使用多次。 中的参数 内的参数 用法： 用法： 添加一些特定参数后会将特定警告忽略 用法： 如果将 的注释去掉就会报错，因为这个注解用于注解函数式接口或者匿名函数。 标识这个注解的注解可以继承： 这样的话 中的输出结果为true，也就说明 的注解继承于 。 的用法： 可以看到这样就可以注解两个相同的注解了。 自定义注解\r使用@interface自定义注解时，自动继承了 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 注解参数的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组 "],["Java集合框架","2022年04月04日","/2022/04/15/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html/","\rJava集合框架\r简介\r集合大致分为 , , 和 四种体系。 ：无序不可重复的集合 ：有序可重复的集合 ：代表正常意义的队列 ：具有映射关系的集合 Set\rHashSet\r通过 算法来对元素进行存储，具有较好的查找和存取性能，但是线程不安全。 的元素不会按照输入的顺序存储，另外判断元素是否相等的标准是 方法和 是否相等 其中 和 方法定义于 类中 其判断两个元素的地址是否相等 当然也可以通过覆盖 方法来重新定义 判断相等的条件。 方法产生 值·，通过 运算确定元素的位置 LinkedHashSet\r通过链表的方式会将元素以输入的顺序连接起来，性能低于 ，但是当遍历所有元素时， 的性能要略高于 TreeSet\r以一种标准将元素排列存储，使用红黑树来实现相应操作 当使用默认排序方式时，元素的类型需要实现 接口，否则会爆出异常，另外元素的类型只能是一种，否则无法进行比较。 当自定义排序方式时，需要将元素的类型实现 接口，实现其中的 方法，定义自己的比较标准 EnumSet\r是专为枚举类定义的集合类型，在其内部也会将元素根据枚举类定义元素的顺序进行定义，不能通过构造器的方式获取其实例，只能通过定义的方法获取 img\rSet性能对比\rEnumSet性能\u0026gt;HashSet性能\u0026gt;LinkedHashSet\u0026gt;TreeSet性能 EnumSet内部以位向量的形式存储，结构紧凑、高效，且只存储枚举类的枚举值，所以最高效。HashSet以hash算法进行位置存储，特别适合用于添加、查询操作。LinkedHashSet由于要维护链表，性能比HashSet差点，但是有了链表，LinkedHashSet更适合于插入、删除以及遍历操作。而TreeSet需要额外的红黑树算法来维护集合的次序，性能最次。 但是具体使用要考虑具体的使用场景。 当需要一个特定排序的集合时，使用TreeSet集合。 当需要保存枚举 类的枚举值时，使用EnumSet集合。 当经常使用添加、查询操作时，使用HashSet。 当经常插入排序或使用删除、插入及遍历操作时，使用LinkedHashSet。 List\r"],["Java高级 - 代理","2022年04月04日","/2022/04/15/java%E9%AB%98%E7%BA%A7-%E4%BB%A3%E7%90%86.html/","\rJava高级 - 代理\r什么是代理\r代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 静态代理\r其中 就是一个代理类，其内部有一个用户类的对象，可以在 类中设置预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。 然后测试 但是这样有一个问题，代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。这时就可以用动态代理了。 动态代理\r动态代理是基于Java的反射机制生成动态代理类的。 动态代理中有一个重要的类 和一个重要的接口 每一个动态代理类的调用处理程序都必须实现 接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现 接口类的invoke方法来调用。 "],["Java高级 - 多线程","2022年04月04日","/2022/04/15/java%E9%AB%98%E7%BA%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B.html/","\rJava高级 - 多线程\r概述\r多线程是多个线程并发进行的技术，进而能够提高整体性能。而一个程序中，独立运行的程序片段叫做线程。 线程与进程的区别： 进程是操作系统资源调度的基本单位，而线程是任务的调度执行的基本单位 进程之间的切换开销较大 进程共享资源困难但是同步简单，而线程则相反。 线程分为四个状态： 新建状态：使用 关键字创建出一个 对象后此线程就处于新建状态，直到调用 方法 就绪状态：调用完 方法后，线程就处于就绪状态，在就绪队列中等待CPU的调度 运行状态：如果就绪状态的线程获取到CPU资源，就可以运行 方法，此时 就处于运行状态，运行状态的线程可以转换到就绪状态，阻塞状态和死亡状态。 死亡状态：一个线程完成任务或者遇到终止代码时就会进入到终止状态 阻塞状态：线程中执行 ， 等方法后线程就处于一种阻塞状态，在睡眠时间已到或者或者从新获取设备资源后就会到就绪状态。阻塞状态分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 线程的优先级\r优先级是一个 的整数，默认情况下线程会分配的优先级是5。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建线程的三种方式\r通过继承 类 通过重写 方法来实现这个线程的任务逻辑 然后在主方法中测试： 通过实现 接口，重写 方法 在 方法中实现线程的逻辑 最后自己写了一个 方法用于给 初始化并调用 而第一种方法中是重写的父类 中的方法 在 方法中测试： 通过 和 来实现 注意：这个 方法是有返回值的 在主方法中调用时： 因为上边在 方法中定义的返回值类型为 ，所以在 中定义泛型类型为 。 多线程的一些重要方法\r方法 在调用 方法的线程运行完之后才会运行其他的线程。 这样会使 执行完之后再执行 方法 该方法不会使线程立即终止 在测试方法中每次都会判断线程是否interrupt,只有响应这个线程才能终止。 注意： 只是将中断码设为true，需要代码实行逻辑。 线程池\r多线程虽然可以提高运行效率，但是如果开启的线程过多，也会造成负面效应，因为在线程创建和销毁的时候会占用很多的CPU资源，造成资源浪费。 这样就引入了线程池\u0026ndash;可以复用一组线程。 线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。 Java标准库提供了 接口表示线程池 因为 只是接口，Java标准库提供的几个常用实现类有： FixedThreadPool：线程数固定的线程池； CachedThreadPool：线程数根据任务动态调整的线程池； 可以设置线程数的范围 SingleThreadExecutor：仅单线程执行的线程池。 这是一个线程实现类 使用线程池调用 观察运行结果就会发现会先运行前四个任务，等四个任务完成（也就是线程空闲后）之后才会运行后面的两个任务 需要反复执行的线程 "],["Java高级 - 泛型","2022年04月04日","/2022/04/15/java%E9%AB%98%E7%BA%A7-%E6%B3%9B%E5%9E%8B.html/","\rJava高级 - 泛型\r泛型列表\r下边这段代码不会报错 因为没有给列表指定泛型类型 但是如果将其强制转换，也就是像下边这样 就会出现 的异常，因为 类型无法强制转换为 类型 但是下边这一段编译时就会报错 因为已经指定了泛型类型，所输入的值就必须为 类型,就不会出现像上边参数类型不一致的问题。 泛型类\r这个类可以通过指定泛型参数 的类型指定传入参数的类型，从而提高适用性。 就像下边这样 泛型接口\r如果它的实现类不指定泛型类型时，那么实现类中的方法就会自动转换位 如果指定类型的话，就会转换为自己指定的类型。 实现类后面的 可有可无 类型通配符\r如果使用下面这段代码时编译时就会报错 因为上边的 是 类型，但是 中的参数却是 类型，虽然 是 的子类，但是仍然不能够将 看做 的子类。 所以如果参数类型不确定时就可以使用下面通配符的方法： 这样就可以使用上边的 代码 可以将 看做是所有类型的父类。 泛型方法\r这个方法用于将传入的数组打印出来 就是泛型方法的标志，当然也可以不只一个参数，例如 这样就可以将多种类型的数组只使用一个方法打印出来： 下边这个方法可以指定参数的边界，也即传入的参数必须是指定类型的子类型或者父类型： 使用时： "],["Java高级 - 锁","2022年04月04日","/2022/04/15/java%E9%AB%98%E7%BA%A7-%E9%94%81.html/","\rJava高级 - 锁\r锁的概述\r当执行到某一个锁的代码块时，其他线程不能够抢占该线程的资源，直到该线程已经执行完释放所对象后，其他线程方能阻断。 有时可能会出现这种问题，当一个线程正在执行某一个操作时，被另一个线程抢占资源，导致一个完整的方法被阻断，造成数据的丢失： 这是一个Bank类，用于各个账户之间的财产的转移。 这是测试方法 运行完之后会发现总资产有时并不为100000也就是所有资产的总和，这就是上面提到的那个问题。 所以这时就引出了锁 锁的应用\r这是一个重入锁，线程可以反复获得已拥有的锁，被一个锁保护的代码可以调用另一个使用相同锁的方法。 这是改造的刚才的 方法，其中 是一个 对象。 注意在调用完 方法后必须再调用 方法,否则可能会造成死锁。 synchronized 这是使用synchronized关键字改造的transfer方法 这是synchronized关键字定义的同步块 注意：使用synchronized关键字时调用wait方法后必须调用notify方法，否则也可能导致死锁。 "],["MySQL笔记","2022年04月04日","/2022/04/15/mysql%E7%AC%94%E8%AE%B0.html/","\rMySQL笔记\rmysql管理\r打开关闭mysql服务器\r在bin目录下 启动 关闭 mysql用户设置\r注意新版本mysql的password字段改为authentication_string字段 创建用户 给用户添加权限 all可替换为制定权限select,delete,update,create,drop 查看用户权限 撤销用户权限 删除用户 或 更改密码 管理mysql命令\r选择要操作的数据库 列出数据库列表 列出指定数据库的所有表 显示数据表的属性 显示数据表的详细索引信息 输出mysql数据库管理系统的性能及统计信息 Mysql创建数据库\r登录后使用create命令创建数据库 使用mysqladmin创建数据库\r使用普通用户，你可能需要特定的权限来创建或者删除 MySQL 数据库。 所以我们这边使用root用户登录，root用户拥有最高权限，可以使用 mysql mysqladmin 命令来创建数据库。 Mysql删除数据库\r使用 mysqladmin 删除数据库\r然后输入密码即可。 Mysql数据类型\r数值类型\rMySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 byte (-128，127) (0，255) 小整数值 SMALLINT 2 bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u0026gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型\r表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\u0026quot;零\u0026quot;值，当指定不合法的MySQL不能表示的值时使用\u0026quot;零\u0026quot;值。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 \u0026lsquo;-838:59:59\u0026rsquo;/\u0026lsquo;838:59:59\u0026rsquo; HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型\r字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 mysql创建数据表\r表名 表字段名 定义每个表字段 语法\r示例 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 也可以使用命令提示符创建表，同上。 删除数据表\r语法： 注意：首先需要指定是哪个数据库。 Mysql插入数据\r语法： Mysql查询数据\r语法： 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 Mysql WHERE语句\r语法： 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true (A = B) 返回false。 \u0026lt;\u0026gt;, != 不等于，检测两个值是否相等，如果不相等返回true (A != B) 返回 true。 \u0026gt; 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true (A \u0026gt; B) 返回false。 \u0026lt; 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true (A \u0026lt; B) 返回 true。 \u0026gt;= 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true (A \u0026gt;= B) 返回false。 \u0026lt;= 小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true (A \u0026lt;= B) 返回 true。 MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 Mysql UPDATE更新\r语法： 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 Mysql DELETE语句\r语法： 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 Mysql LIKE子句\rSQL LIKE 子句中使用百分号 **%**字符来表示任意字符，类似于UNIX或正则表达式中的星号 *****。 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法： 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE\u0026hellip;LIKE 子句来指定条件。 Mysql UNION语句\rMySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法： expression1, expression2, \u0026hellip; expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 Mysql 排序\r语法： 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC（升序） 或 DESC（降序） 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE\u0026hellip;LIKE 子句来设置条件。 Mysql GROUP BY 语句\r在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 语法： Mysql ALTER命令\r删除，添加和修改表字段\r如下命令使用了 ALTER 命令及 DROP 子句来删除field字段： 如果数据表中只剩余一个字段则无法使用DROP来删除字段。 添加字段： 如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。 示例： 修改字段类型及名称\r如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。 把字段 c 的类型从 CHAR(1) 改为 CHAR(10) 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。 ALTER TABLE 对NULL值和默认值的影响 以下实例，指定字段 j 为 NOT NULL 且默认值为100 。 修改字段默认值 删除字段默认值 修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。 修改表名 "],["OkHttp笔记","2022年04月04日","/2022/04/15/okhttp%E7%AC%94%E8%AE%B0.html/","\rOkHttp笔记\r概述及优点\r一个高效的HTTP客户端： HTTP/2支持对所有主机的所有请求共享一个套接字。 连接池减少了请求延迟。 透明GZIP可缩小下载大小。 响应缓存完全避免网络重复请求。 第一次连接失败时会尝试使用备用地址。 请求和响应API设计有流畅的构建器和不变性，支持同步阻塞调用和带有回调的异步调用。 获取网页内容\rrun方法下载URL并返回其内容的字符串。 发布到服务器\r通过RequestBody的create方法，传入两个参数，第一个参数是内容类型，第二个参数是要发送的数据，创建RequestBody的实例,然后调用post方法将其传入。 版本\r建议使用最新版本\rOkHttp一个用于测试HTTP,HTTPS,和HTTP/2客户端的库（模拟网络服务器）。 最新版本\rCall\rHTTP 客户端的工作是接受您的请求并产生其响应。 Request\r每个 HTTP 请求都包含一个 URL、一个方法（如 或 ）和一个标头列表。请求还可能包含一个主体：特定内容类型的数据流。 Response\rHTTP 响应。这个类的实例不是一成不变的：响应体是一个一次性值，可能只被消费一次然后关闭。所有其他属性都是不可变的。 此类实现Closeable\r。关闭它只是关闭它的ResponseBody. 响应主体必须关闭\r每个响应主体都由有限的资源支持，如套接字（实时网络响应）或打开的文件（用于缓存响应）。未能关闭响应正文将泄漏资源并最终可能导致应用程序变慢或崩溃。 这个类和Response 都\r实现了Closeable\r。关闭响应只是关闭其响应主体。如果调用Call.execute\r或实现Callback.onResponse\r，则必须通过调用以下任何方法来关闭此主体： 为同一个响应体调用多个close()方法没有任何好处。 对于同步调用，确保响应主体关闭的最简单方法是使用 块。使用这种结构，编译器会插入一个为您 调用close()\r的隐式子句 。 可以使用类似的块进行异步调用： 如果您在另一个线程上使用响应正文，这些示例将不起作用。在这种情况下，消费线程必须在完成读取响应正文后调用close\r。 ResponseBody只能被consume一次。\r此类可用于流式传输非常大的响应。例如，可以使用此类读取大于分配给当前进程的整个内存的响应。它甚至可以流式传输大于当前设备上总存储量的响应，这是视频流应用程序的常见要求。 由于此类不在内存中缓冲完整的响应，因此应用程序可能不会重新读取响应的字节。使用这一次将整个响应以字节\r或字符串\r读入内存 。或者使用source\r、byteStream\r或charStream\r流式传输响应。 重写请求\r当您向 OkHttp 提供 HTTP 请求时，您是在高级别描述该请求：“使用这些标头为我获取此 URL。” 为了正确性和效率，OkHttp 在传输之前重写您的请求。 OkHttp可以添加标头是从原来的请求不存在，包括 ， ， ， ， ，和 。 除非标头已经存在，否则它将为透明响应压缩添加标头。如果您有 cookie，OkHttp 会 为它们添加一个标头。 某些请求将具有缓存的响应。当这个缓存的响应不新鲜时，如果更新的响应比缓存的更新，OkHttp 可以执行有条件的 GET来下载更新的响应。这需要添加像 和这样的标题 。 重写响应\r如果使用透明压缩，OkHttp 将丢弃相应的响应头 ， 因为它们不适用于解压的响应体。 如果条件 GET 成功，来自网络和缓存的响应将按照规范的指示进行合并。 跟进请求\r当您请求的 URL 移动时，网络服务器将返回一个响应代码，类似于 指示文档的新 URL。OkHttp 将跟随重定向来检索最终响应。 如果响应发出授权质询，OkHttp 将要求 （如果已配置）满足质询。如果身份验证器提供凭据，则会重试包含该凭据的请求。 重试请求\r有时连接失败：池连接陈旧并断开连接，或者无法访问网络服务器本身。如果可用，OkHttp 将使用不同的路由重试请求。 Call\r通过重写、重定向、跟进和重试，您的简单请求可能会产生许多请求和响应。OkHttp 用于 通过许多中间请求和响应来模拟满足您的请求的任务。通常这不是很多！但令人欣慰的是，如果您的 URL 被重定向或故障转移到备用 IP 地址，您的代码将继续工作。 调用以以下两种方式之一执行： **同步：**您的线程阻塞，直到响应可读。 **异步：**您在任何线程上排队请求，并在响应可读时在另一个线程上回调\r。 可以从任何线程取消调用。如果它还没有完成，这将使调用失败！编写请求正文或读取响应正文的代码 在调用被取消时会受到影响。 派遣\r对于同步调用，您可以使用自己的线程并负责管理您同时发出的请求数。同时连接太多会浪费资源；太少会损害延迟。 对于异步调用， 实现最大并发请求的策略。您可以设置每个网络服务器的最大值（默认为 5）和整体（默认为 64）。 缓存\r缓存对文件系统的 HTTP 和 HTTPS 响应，以便它们可以被重用，从而节省时间和带宽。 缓存优化\r为了衡量缓存有效性，此类跟踪三个统计信息： **请求计数：**自此缓存创建以来发出的 HTTP 请求数。 **网络计数：**需要网络使用的那些请求的数量。 **命中计数：**响应由缓存提供的那些请求的数量。 有时请求会导致条件缓存命中。如果缓存包含响应的陈旧副本，客户端将发出一个有条件的 . 然后服务器将发送更新的响应（如果已更改），或者如果客户端的副本仍然有效，则发送简短的“未修改”响应。此类响应会增加网络计数和命中计数。 提高缓存命中率的最佳方法是配置 Web 服务器以返回可缓存的响应。尽管此客户端支持所有HTTP/1.1 (RFC 7234)\r缓存标头，但它不会缓存部分响应。 强制网络响应\r在某些情况下，例如用户单击“刷新”按钮后，可能需要跳过缓存，直接从服务器获取数据。要强制完全刷新，请添加 指令： 如果只需要强制服务器验证缓存的响应，请改用更高效的 指令： 强制缓存响应\r有时，如果资源立即可用，您会想要显示资源，否则不会显示。这可以用于让您的应用程序可以在等待下载最新数据时显示一些内容。要将请求限制为本地缓存资源，请添加 指令： 在陈旧的响应比没有响应更好的情况下，这种技术更有效。要允许陈旧的缓存响应，请使用 以秒为单位的最大陈旧程度的指令： 该CacheControl\r类可以配置请求高速缓存的指令和响应解析缓存指令。它甚至提供了方便的常量CacheControl.FORCE_NETWORK\r和 CacheControl.FORCE_CACHE\r来解决上述用例。 连接\rOkHttp 使用三种类型来规划其与您的网络服务器的连接：URL、地址和路由。 HttpUrl\r一个统一的资源定位符 (URL)，其方案为 或 。使用此类来组合和分解 Internet 地址。例如，此代码将编写并打印用于 Google 搜索的 URL： 打印： 作为另一个示例，此代码打印 Twitter 搜索的人类可读查询参数： 打印： 除了从它们的组成部分组成 URL 并将 URL 分解成它们的组成部分之外，这个类还实现了相对 URL 解析：通过单击指定页面上的相对链接，您将到达什么地址。例如： 打印： HttpUrl的组成部分\r方案（scheme）\r有时也称为协议，URL 的方案描述了应该使用什么机制来检索资源。尽管 URL 有许多方案（ 、 、 ），但此类仅支持 和 。将java.net.URI\r用于具有任意方案的 URL。 用户名和密码\r用户名和密码可以存在也可以为空字符串。这个类没有提供区分空和缺席的机制。这些组件在实践中都不流行。通常，HTTP 应用程序使用其他机制进行用户识别和验证。 Host\r主机标识为 URL 资源提供服务的网络服务器。它可以是类似 或的主机名、类似 IPv4 地址 或类似 IPv6 地址 。 通常可以使用多个标识符访问网络服务器：其 IP 地址、注册域名，甚至 从服务器本身连接时。每个 Web 服务器的名称都是一个不同的 URL，它们不可互换。例如，即使 和 由相同的 IP 地址提供服务，这两个 URL 标识不同的资源。 Port\r用于连接到 Web 服务器的端口。默认情况下，HTTP 为 80，HTTPS 为 443。此类从不为端口返回 -1：如果在 URL 中未明确指定端口，则使用方案的默认值。 Path\r该路径标识主机上的特定资源。路径具有像“/square/okhttp/issues/1486”这样的层次结构，并分解成像 . 此类提供按段组合和分解路径的方法。它通过在“/”和编码段之间交替来从段列表中组成每个路径。例如，段 构建“/a/b”，段 构建“/a/b/”。 如果路径的最后一段是空字符串，则路径以“/”结尾。此类始终构建非空路径：如果省略路径，则默认为“/”。默认路径的段列表是一个空字符串： 。 Query\r查询是可选的：它可以为null、空或非空。对于许多 HTTP URL，查询字符串被细分为一组名称-值参数。此类提供了将查询设置为单个字符串或单独的名称-值参数的方法。对于名称-值参数，这些值是可选的并且名称可以重复。 Fragment\r片段是可选的：它可以为空、空或非空。与主机、端口、路径和查询不同，片段不会发送到网络服务器：它是客户端私有的。 编码\r每个组件都必须在嵌入完整 URL 之前进行编码。正如我们在上面看到的，字符串 被编码为 当用作查询参数值时。 百分比编码\r百分比编码将字符（如 ）替换为其 UTF-8 十六进制字节（如 ）。这种方法适用于空白字符、控制字符、非 ASCII 字符和在特定上下文中已经具有另一种含义的字符。 除了主机名之外，每个 URL 组件都使用百分比编码。但是每个组件需要编码的字符集是不同的。例如，路径组件必须对其所有 字符进行转义，否则它可能会被解释为 URL 查询的开始。但是在 query 和 fragment 组件中， 字符没有分隔任何东西，也不需要转义。 这打印： 当解析缺少百分比编码的 URL 时，此类将对违规字符进行百分比编码。 IDNA映射和Pinycode编码\r主机名有不同的要求并使用不同的编码方案。它由 IDNA 映射和 Punycode 编码组成。 为了避免混淆和阻止网络钓鱼攻击，IDNA Mapping 会\r转换名称以避免混淆字符。这包括基本的案例折叠：将喊叫 转变为冷静和随意 。它还可以处理更多异国情调的角色。例如，Unicode 商标符号 (™) 可能与 混淆. 为了缓解这种情况，单个字符 (™) 映射到字符串 ™。所有 110 万个 Unicode 代码点都有类似的政策。请注意，某些代码点（例如“\\ud83c\\udf69”）未映射且不能在主机名中使用。 Punycode\r将 Unicode 字符串转换为 ASCII 字符串，使国际域名在任何地方都能使用。例如，“σ”编码为“xn–4xa”。编码后的字符串不是人类可读的，但可以与InetAddress 等\r类一起使用以建立连接。 地址\r地址指定网络服务器（如 ）和连接到该服务器所需的所有静态配置：端口号、HTTPS 设置和首选网络协议（如 HTTP/2 或 SPDY）。 共享相同地址的 URL 也可能共享相同的底层 TCP 套接字连接。共享连接具有显着的性能优势：更低的延迟、更高的吞吐量（由于TCP 慢启动\r）和节省电池。OkHttp 使用ConnectionPool\r自动重用 HTTP/1.x 连接并复用 HTTP/2 和 SPDY 连接。 在 OkHttp 中，地址的某些字段来自 URL（方案、主机名、端口），其余字段\r来自OkHttpClient\r。 路线\r路由提供实际连接到网络服务器所需的动态信息。这是要尝试的特定 IP 地址（由 DNS 查询发现）、要使用的确切代理服务器（如果正在使用ProxySelector\r）以及要协商的 TLS 版本（对于 HTTPS 连接）。 一个地址可能有许多路由。例如，托管在多个数据中心的网络服务器可能会在其 DNS 响应中产生多个 IP 地址。 连接用于到达抽象源服务器的具体路由。创建连接时，客户端有很多选项： **HTTP 代理：**可以为客户端显式配置代理服务器。否则使用代理选择器\r。它可能尝试会返回多个代理。 **IP地址：**无论是直接连接到源服务器还是代理，打开一个socket都需要一个IP地址。DNS 服务器可能会返回多个 IP 地址进行尝试。 每条路线都是这些选项的特定选择。 连接\r当您使用 OkHttp 请求 URL 时，它会执行以下操作： 它使用 URL 和配置好的 OkHttpClient 来创建地址。这个地址指定了我们将如何连接到网络服务器。 它尝试从连接池中检索具有该地址的连接。 如果它在池中没有找到连接，它会选择一个路由来尝试。这通常意味着发出 DNS 请求以获取服务器的 IP 地址。然后，它会根据需要选择 TLS 版本和代理服务器。 如果是新路由，它会通过构建直接套接字连接、TLS 隧道（用于 HTTP 代理上的 HTTPS）或直接 TLS 连接来进行连接。它会根据需要进行 TLS 交互。 它发送 HTTP 请求并读取响应。 如果连接出现问题，OkHttp 会选择另一条路由并重试。这允许 OkHttp 在无法访问服务器地址的子集时进行恢复。当池连接陈旧或尝试的 TLS 版本不受支持时，它也很有用。 收到响应后，连接将返回到池中，以便可以在以后的请求中重用。在一段时间不活动后，连接将从池中逐出。 事件\r事件图\r这是一个示例事件侦听器\r，它使用时间戳打印每个事件。 我们发出了几个call 并且侦听器打印相应的事件： 注意第二次调用没有触发连接事件。它重用了来自第一个请求的连接以获得显着更好的性能。 事件监听器Factory\r在前面的示例中，我们使用字段 , 来跟踪每个事件的经过时间。这很方便，但如果多个调用同时执行，它就行不通了。为了适应这种情况，使用 创建一个新的 为每个实例 。这允许每个侦听器保持特定于呼叫的状态。 此示例工厂\r为每个调用创建一个唯一 ID，并使用该 ID 来区分日志消息中的调用。 我们可以使用这个监听器来竞争一对并发 HTTP 请求： 在家庭 WiFi 上运行这场比赛显示 Times ( ) 完成得比 Post ( )稍早： 这 还可以将指标限制为调用的子集。这个捕获随机 10% 的指标： 失败的Event\r当操作失败时，会调用失败方法。这适用 于建立与服务器的连接 时的失败，以及HTTP 调用永久失败的情况。当发生故障时， 事件可能没有相应的 事件。 事件图\r带有重试和跟进的事件\rOkHttp 具有弹性，可以从某些连接故障中自动恢复。在这种情况下， 事件不是终止事件，并且后面没有 。尝试重试时，事件侦听器将接收多个相同类型的事件。 单个 HTTP 调用可能需要发出后续请求来处理身份验证挑战、重定向和 HTTP 层超时。在这种情况下，可能会尝试多个连接、请求和响应。跟进是单个调用可能触发多个相同类型事件的另一个原因。 事件图\rHTTPS\rOkHttp尽可能的协调两个问题： 连接到尽可能多的主机 连接的安全性 ConnectionSpec\r实现了特定的安全性与连接性决策。OkHttp 包含四个内置连接规范： 是一种安全配置，旨在满足更严格的合规性要求。 是连接到现代 HTTPS 服务器的安全配置。 是连接到安全但不是当前的 HTTPS 服务器的安全配置。 是用于 URL的不安全配置。 代码示例\rHttp Get 代码分析： 最好全局使用一个OkHttpClient 创建一个request,可以通过RequestBuider设置参数 通过request对象构造call对象，可以调用execute和cancel方法 异步调用，call.enqueue,等待任务执行完成，在calllback中获取结果 当整个GET成功，我们就回调在onResponse()方法中的方法处理ResponseBody包含的数据。通过response.body()方法得到ResponseBody对象。ResponseBody有几种方式转换返回的数据。 Call有一个线程阻塞方法，execute()。可以直接调用这个方法返回一个Response。 注意当我们使用Call.execute()方法返回的Response，首先要进行判断是否成功。调用Response.isSuccessful()（Returns true if the code is in [200..300),这里的code指的是Http响应消息的状态码）方法来判断。 Http Post post 提交Json数据\r使用Request的post方法来提交请求体RequestBody post提交键值对\r"],["Retrofit 笔记","2022年04月04日","/2022/04/15/retrofit-%E7%AC%94%E8%AE%B0.html/","\rRetrofit 笔记\r概述\r一种适用于Android和Java的HTTP客户端 Retrofit将HTTP API转换为一个Java接口 Retrofit 类的实例可以产生一个实现了GithubService接口的类的实例。 创建的每个 都可以向远程 Web 服务器发出同步或异步 HTTP 请求。 使用注解来描述 HTTP 请求： URL 参数替换和查询参数支持 对象转换为请求正文（例如，JSON、协议缓冲区） 分段请求正文和文件上传 注意： 准确来说，Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。 原因：网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装 本质过程\rApp应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作 在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析 API 声明\r请求方法\r每个方法都必须有一个提供请求方法和相对 URL 的 HTTP 注释。有八个内置注释： ， ， ， ， ， ， 和 。资源的相对 URL 在注释中指定。 您还可以在 URL 中指定查询参数。 网址操作\r可以使用方法上的替换块和参数动态更新请求 URL。替换块在{}中，相应的参数必须用@Path使用相同的字符串进行注释。 也可以添加查询参数 对于复杂的查询参数可以使用Map 请求正文\r可以指定一个对象作为带有 注释的 HTTP 请求正文。 该对象也将使用 实例上指定的转换器进行转换。如果不添加转换器，则只能使用RequestBody。 Form Encoding和多部分\r可以声明方法来发送表单编码和多部分数据。 当 存在于方法中时发送表单编码数据。每个键值对都被注释为 包含名称和提供值的对象。 方法中存在时使用多部分请求。部件是使用 注释声明的。 多部分部件使用 的转换器之一，或者它们可以实现 来处理自己的序列化。 Header操作\r您可以使用 注释为方法设置静态标头。 注意，标头不会相互覆盖。所有具有相同名称的标头都将包含在请求中。 可以使用 注解动态更新请求头。必须向’@Header提供相应的参数。如果值为 null，则将省略标头。否则， 将调用该值，并使用结果。 对于复杂的Header组合也可以用Map来代替 可以使用OkHttp 拦截器\r指定需要添加到每个请求的标头\r。 同步和异步\r实例可以同步或异步执行。每个实例只能使用一次，但是调用 会创建一个可以使用的新实例。 在 Android 上，回调将在主线程上执行。在 JVM 上，回调将发生在执行 HTTP 请求的同一线程上。 改造配置\r是将 API 接口转换为可调用对象的类。默认情况下，Retrofit 将为您的平台提供合理的默认值，但它允许自定义。 转换器\r默认情况下，Retrofit 只能将 HTTP 主体反序列化为 OkHttp 的 类型，并且只能接受其 类型为 . 可以添加转换器以支持其他类型。为了您的方便，六个兄弟模块采用流行的序列化库。 Gson\r: Jackson\r: Moshi\r: Protobuf\r: Wire\r: Simple XML\r: JAXB\r: Scalars (primitives, boxed, and String): 这是使用 该类生成 使用 Gson 进行反序列化的接口实现的示例。 自定义转换器\r如果您需要与使用 Retrofit 不支持的内容格式（例如 YAML、txt、自定义格式）的 API 进行通信，或者您希望使用不同的库来实现现有格式，您可以轻松创建你自己的转换器。创建一个继承于 类\r的类，并在构建适配器时传入一个实例。 最新 JAR包\r使用\r步骤1：添加Retrofit库的依赖并添加网络权限\r步骤2：创建接受服务器返回数据的类\r步骤3：创建用于描述网络请求的接口\r注意： 用 动态代理 动态 将该接口的注解“翻译”成一个 Http 请求，最后再执行 Http 请求 接口中的每个方法的参数都需要使用注解标注，否则会报错 Retrofit把 网络请求的URL 分成了两部分设置： 网络请求的完整 Url =在创建Retrofit实例时通过.baseUrl()设置 +网络请求接口的注解设置（下面称 “path“ ） URL整合规则\r@Header \u0026amp; @Headers（请求头\u0026amp;不固定请求头） @Body 注意：如果提交的是一个Map，那么作用相当于 @Field \u0026amp; @FieldMap 与 注解配合使用 @Part \u0026amp; @PartMap 作用：发送 Post请求 时提交请求的表单字段 与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景，与 注解配合使用 @Query和@QueryMap @Path 作用：URL地址的缺省值 @Url 直接传入一个请求的 URL变量 用于URL设置 步骤4：创建Retrofit实例\rRetrofit支持多种网络请求适配器方式：guava、Java8和rxjava 使用时如使用的是 默认的 ，则不需要添加网络请求适配器的依赖，否则则需要按照需求进行添加 Retrofit 提供的 步骤5：创建网络请求接口实例\r步骤6: 发送网络请求（异步和同步）\r步骤7：处理返回数据\r"],["SQLite笔记","2022年04月04日","/2022/04/15/sqlite%E7%AC%94%E8%AE%B0.html/","\rSQLite笔记\rSQLite语法\r注释\rSQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。 SQL 注释以两个连续的 \u0026ldquo;-\u0026rdquo; 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。 也可以使用 C 风格的注释，以 \u0026ldquo;/\u0026rdquo; 开始，并扩展至下一个 \u0026ldquo;/\u0026rdquo; 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。 SQLite创建数据库\r注：不需要进入sqlite命令行 也可以通过 来创建数据库。 打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。 退出sqlite提示符 .dump命令\r可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中， 转储到 ASCII 文本文件 testDB.sql 中. 恢复： SQLite 附加数据库\r如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 \u0026lsquo;Alias-Name\u0026rsquo; 绑定在一起。 打开的数据库和使用 ATTACH附加进来的数据库的必须位于同一文件夹下。 数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息， SQLite 分离数据库\r在这里，\u0026lsquo;Alias-Name\u0026rsquo; 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。 SQLite INSERT语句\r可以使用一个表来填充另外一个表 可以设置输出列的宽度 Schema信息\r可以列出关于 COMPANY 表的完整信息，如下所示： 假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果： SQLite运算符\r算术运算符 比较运算符 逻辑运算符 位运算符 ==\t=\t!=\t\u0026lt;\u0026gt;(不等于)\t\u0026gt; \u0026lt;\t\u0026gt;=\t\u0026lt;=\t!\u0026lt;\t!\u0026gt; 运算符 描述 AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。 EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。 IN IN 运算符用于把某个值与一系列指定列表的值进行比较。 NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。 GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。 IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。 IS IS 运算符与 = 相似。 IS NOT IS NOT 运算符与 != 相似。 || 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 SQLite Like语句\r百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。（大小写不敏感） Glob 语句(大小写敏感型)： 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 SQLite Having语句\rHAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。 WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 "]]